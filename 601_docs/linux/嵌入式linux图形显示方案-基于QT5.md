# 嵌入式Linux图形显示方案

版本|日期|作者
--|--|--
1.0  |   |周星宇  

## 方案1：QT自带GDI绘图


绘图性能奇慢无比,


## 方案2: 使用OpenGL

条件:下位机芯片要有GPU，支持OpenGL规范

### QGLWidget类
该QGLWidget来绘图类是绘制OpenGL图形的Widget。

QGLWidget提供了显示集成到Qt应用程序中的OpenGL图形的功能。它使用起来非常简单。您继承它并像使用任何其他QWidget一样使用子类，除了您可以选择使用QPainter和标准OpenGL渲染命令。

注意：此类是遗留Qt OpenGL模块的一部分，与其他QGL类一样，应该在新应用程序中避免使用。相反，从Qt 5.4开始，更喜欢使用QOpenGLWidget和QOpenGL类。

QGLWidget提供了三个方便的虚函数，您可以在子类中重新实现以执行典型的OpenGL任务：

+ paintGL（） - 渲染OpenGL场景。每当需要更新窗口小部件时都会调用它。
+ resizeGL（） - 设置OpenGL视口，投影等。每当调整窗口小部件的大小时（以及第一次显示窗口小部件时）都会调用它，因为所有新创建的窗口小部件都会自动获得调整大小事件。
+ initializeGL（） - 设置OpenGL渲染上下文，定义显示列表等。在第一次调用resizeGL（）或paintGL（）之前调用一次

参考:https://doc.qt.io/qt-5.6/qglwidget.html

### OpenGL渲染API

使用的是OpenGL的跨平台通用API

## 方案3:直接操作FrameBuffer

framebuffer简介 

    帧缓冲（framebuffer）是Linux为显示设备提供的一个接口，把显存抽象后的一种设备，他允许上层应用程序在图形模式下直接对显示缓冲区进行读写操作。framebuffer是LCD对应的一中HAL（硬件抽象层），提供抽象的，统一的接口操作，用户不必关心硬件层是怎么实施的。这些都是由Framebuffer设备驱动来完成的。 
    帧缓冲设备对应的设备文件为/dev/fb*，如果系统有多个显示卡，Linux下还可支持多个帧缓冲设备，最多可达32个，分别为/dev/fb0到 /dev/fb31，而/dev/fb则为当前缺省的帧缓冲设备，通常指向/dev/fb0，在嵌入式系统中支持一个显示设备就够了。帧缓冲设备为标准字符设备，主设备号为29，次设备号则从0到31。分别对应/dev/fb0-/dev/fb31。

通过/dev/fb，应用程序的操作主要有这几种： 
1. 读/写（read/write）/dev/fb：相当于读/写屏幕缓冲区。 
1. 映射（map）操作：由于Linux工作在保护模式，每个应用程序都有自己的虚拟地址空间，在应用程序中是不能直接访问物理缓冲区地址的。而帧缓冲设备可以通过mmap()映射操作将屏幕缓冲区的物理地址映射到用户空间的一段虚拟地址上，然后用户就可以通过读写这段虚拟地址访问屏幕缓冲区，在屏幕上绘图了。 
1. I/O控制：对于帧缓冲设备，对设备文件的ioctl操作可读取/设置显示设备及屏幕的参数，如分辨率，屏幕大小等相关参数。ioctl的操作是由底层的驱动程序来完成的。

在应用程序中，操作/dev/fb的一般步骤如下： 
1. 打开/dev/fb设备文件。 
1. 用ioctl操作取得当前显示屏幕的参数，根据屏幕参数可计算屏幕缓冲区的大小。 
1. 将屏幕缓冲区映射到用户空间。 
1. 映射后即可直接读写屏幕缓冲区，进行绘图和图片显示。



参考文档:

https://blog.csdn.net/luxiaoxun/article/details/7622988
